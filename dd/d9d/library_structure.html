<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>wisdom: Library Structure</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">wisdom
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dd/d9d/library_structure.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Library Structure</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page provides an overview of the Wisdom library structure and its components.</p>
<h1><a class="anchor" id="overview_sec"></a>
Overview</h1>
<p>The Wisdom library is structured into several modules, each providing a specific functionality. The provided classes and functions are designed to be easy to use and overhead free. When using the library as a header-only library, all the functions are inline and do not incur any overhead. Most of the classes are done in an independent way, so you only need to store classes that you need. The classes, as well as functions and types and their respective documentation, are generated to maintain consistency of interface and ease of use. Files that generate everything are stored at <code>xml</code> directory. Those files can be used to generate the API and its documentation in any other language, providing you have a geneartor and a way to link those functions to C++ code.</p>
<h1><a class="anchor" id="how_it_works"></a>
How It Works</h1>
<p>The library sits above the DirectX 12 and Vulkan APIs, providing a minimal abstraction layer. The library implementation is split into 2 implementations: one for DirectX 12 and one for Vulkan. Both implementations are designed to be as similar as possible, providing a consistent interface for the user. The library also does not use virtual functions, so it is as fast as possible.</p>
<p>The implementation for DirectX 12 is done in the <code>wisdom/dx12</code> directory, while the implementation for Vulkan is done in the <code>wisdom/vulkan</code> directory. DirectX 12 implementation is prefixed with <code>DX12</code> and Vulkan implementation is prefixed with <code>VK</code>. So the classes are named <code>DX12Factory</code>, <code>DX12Adapter</code>, <code>VKFactory</code>, <code>VKAdapter</code> and so on.</p>
<p>Then the implementation is wrapped into the <code>wis::Factory</code>, <code>wis::Adapter</code>, <code>wis::Device</code> and so on. File <code>wisdom/include/wisdom/wisdom.hpp</code> is the main header file that includes all the necessary headers for the library. It also selects the implementation based on the platform and the API. On Windows, it will use DirectX 12 implementation, while on Linux it will use Vulkan implementation.</p>
<dl class="section note"><dt>Note</dt><dd>To use Vulkan implementation on Windows, you can set the <code>WISDOM_FORCE_VULKAN</code> CMake flag to <code>ON</code> or define <code>WISDOM_FORCE_VULKAN</code> in global preprocessor. NuGet package also has this flag in the propertiy page of the project.</dd></dl>
<p>The implementation will scan if you have Vulkan SDK installed and if it is available, it will use Vulkan implementation. Otherwise it will produce an error that Vulkan is not available.</p>
<dl class="section note"><dt>Note</dt><dd>For modules there are 2 implementations - one uses regular module name <code>import wisdom</code> and the other uses <code>import wisdom.fvk</code>. This is done due to the fact that preprocessor switches do not affect modules imported from other libraries. You cannot use both imports in the same project, so you should choose one of them. Althogh both modules provide implemntations for both DirectX 12 and Vulkan.</dd></dl>
<h1><a class="anchor" id="using_types"></a>
Types</h1>
<p>Only .hpp files provided to be used in your project. The .h files contain the implementation details and are not meant to be used directly. However types that they provide can be used directly in your project. One use case is to use both DirectX 12 and Vulkan implementations in the same project. In such case you should use prefixed types, like <code>wis::DX12Factory</code> and <code>wis::VKFactory</code>, to avoid name clashes. Functions that create device and factory are also prefixed with <code>DX12</code> or <code>VK</code> for that particular reason.</p>
<p>For regular use you can use the <code>wis::Factory</code>, <code>wis::Adapter</code>, <code>wis::Device</code> and so on types, which are the main types of the library. All the extensions and platform-specific addons follow the same naming convention, so you can use them without any issues.</p>
<p>All the examples and documentation will be provided with non-prefixed types to simplify the usage.</p>
<p>All the types have a destructor and independent lifetime, so you can use them without worrying about the lifetime of the underlying resources. For example, if <code>wis::Device</code> is destroyed before <code><a class="el" href="../../d1/d34/namespacewis.html#a533b709d7bd76dadcbc1f432ba1b8218a7e62bc342f41c946868f0ea6f0b712d8" title="Descriptor is a shader resource buffer. May be bigger than constant buffers, but slower.">wis::Buffer</a></code>, the buffer will still be valid and can be used. The underlying resources will be released when the last reference to them is destroyed. The library uses RAII principles to manage the lifetime of the resources, so you don't have to worry about memory leaks or resource management. Most of the classes are move-only, so you can use them without worrying about copying the resources.</p>
<h1><a class="anchor" id="api_api"></a>
API</h1>
<p>Provided API is designed to be easy to use and understand. It is based on the modern C++ standards and best practices. Most of the API functions return <code><a class="el" href="../../d5/dc8/structwis_1_1Result.html" title="Main source of communication of operation success. To check for success compare wis::Result::status w...">wis::Result</a></code> type, which is a simple wrapper around the error code and the error message. Error messages are brief and compile-time created, and their lifetime is static, so you can use them without worrying about the lifetime of the error message. Since the library is designed to be used with modern C++ standards, output is best handled with structured bindings.</p>
<p>Example of how to use the API: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp;&amp; [result, factory] = wis::CreateFactory();</div>
</div><!-- fragment --><p>The <code>CreateFactory</code> function will return a <code><a class="el" href="../../d5/dc8/structwis_1_1Result.html" title="Main source of communication of operation success. To check for success compare wis::Result::status w...">wis::Result</a></code> and a <code>wis::Factory</code> object. The <code><a class="el" href="../../d5/dc8/structwis_1_1Result.html" title="Main source of communication of operation success. To check for success compare wis::Result::status w...">wis::Result</a></code> object will contain the error code and the error message, while the <code>wis::Factory</code> object will contain the factory object.</p>
<p>The library also provides RVO (Return Value Optimization) for the functions that return objects. Those functions will return the object directly, and result will be stored in the first argument of the function.</p>
<p>Example of how to use the API with RVO: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="../../d5/dc8/structwis_1_1Result.html">wis::Result</a> result = wis::success;</div>
<div class="line"><span class="keyword">auto</span> factory = wis::CreateFactory(result);</div>
<div class="ttc" id="astructwis_1_1Result_html"><div class="ttname"><a href="../../d5/dc8/structwis_1_1Result.html">wis::Result</a></div><div class="ttdoc">Main source of communication of operation success. To check for success compare wis::Result::status w...</div><div class="ttdef"><b>Definition</b> <a href="../../d4/df0/api_8hpp_source.html#l01534">api.hpp:1534</a></div></div>
</div><!-- fragment --><p>Those functions are generated with first argument being <code><a class="el" href="../../d5/dc8/structwis_1_1Result.html" title="Main source of communication of operation success. To check for success compare wis::Result::status w...">wis::Result</a>&amp;</code> and returning the object directly. So if you want to squeeze the last bit of performance, you can use this approach, since it will avoid using extra move constructor or move assignment.</p>
<h1><a class="anchor" id="extension"></a>
Extending the Library</h1>
<p>The library is designed to be extensible, so you can add your own extensions and functionality to it. Open-ended extensibility is one of the key features of the library. Every class has a corresponding Internal class that provides the implementation details. To query the internal implementation, you can use the <code>GetInternal</code> and <code>GetMutableInternal</code>. Once you have the internal implementation, you can use it to extend the library with your own functionality. To follow the practice you can see the implementation of any extension from <code>wisdom/extensions</code> directory.</p>
<p>You don't have to use the same conventions as the library does, but it is recommended to follow the same naming conventions and structure to keep the code consistent and easy to read.</p>
<dl class="section note"><dt>Note</dt><dd>Although the library provides internals, it is not recommended to rely on them in your code. The internals are subject to change and may not be stable across different versions of the library. Although logical components like <code>wis::DX12Device</code> having <code>ID3D12Device*</code> are guaranteed to exist as long as underlying APIs don't change the logic. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
