<?xml version="1.0" encoding="UTF-8"?>
<registry>
  <includes>
    <include>structs.xml</include>
  </includes>

  <handles>
    <handle name="Factory" doc="Class for creating adapters.
Can be safely destroyed after adapter has been chosen.">
      <file for="vk" include="vulkan/vk_factory.h"/>
      <file for="dx" include="dx12/dx12_factory.h"/>
    </handle>

    <handle name="Adapter" doc="Represents physical device.
Can safely be deleted once logical device has been created.">
      <file for="vk" include="vulkan/vk_adapter.h"/>
      <file for="dx" include="dx12/dx12_adapter.h"/>
    </handle>


    <handle name="Device" doc="Represents logical device.
Creates all the resources and commands for rendering.">
      <file for="vk" include="vulkan/vk_device.h"/>
      <file for="dx" include="dx12/dx12_device.h"/>
    </handle>


    <handle name="Fence"/>
    <handle name="ResourceAllocator"/>
    <handle name="RootSignature"/>
    <handle name="CommandQueue"/>
    <handle name="Shader"/>
    <handle name="PipelineState"/>
    <handle name="CommandList"/>
    <handle name="Buffer"/>
    <handle name="Texture"/>
    <handle name="SwapChain"/>
    <handle name="DebugMessenger"/>
    <handle name="RenderTarget"/>
    <handle name="DescriptorBuffer"/>
    <handle name="Sampler"/>
    <handle name="Memory"/>
    <handle name="ShaderResource"/>
    <handle name="FactoryExtension"/>
    <handle name="DeviceExtension"/>
  </handles>

  <functions>
    <!-- Factory -->
    <func for="Factory" name="Destroy" mod="custom-impl" doc="Destroys the {Factory::} and all the extensions created by it.
Order of destruction is Extensions in which they were created, then factory."/>

    <func for="Factory" name="GetAdapter" doc="Creates the {Adapter::} for the factory with provided index.">
      <ret type="Adapter" name="adapter" result="true" doc="{Adapter::} on success ({Status::Ok})."/>
      <arg type="u32" name="index" doc="The index of the adapter to get."/>
      <arg type="AdapterPreference" name="preference" default="wis::AdapterPreference::Performance" doc="The preference of the adapter to get.
Default is {AdapterPreference::Performance}."/>
    </func>

    <!-- Adapter -->
    <func for="Adapter" name="Destroy" doc="Destroys the {Adapter::}."/>

    <func for="Adapter" name="GetDesc" doc="Fills {AdapterDesc::} with physical adapter's data.">
      <ret result="true"/>
      <arg type="AdapterDesc" name="inout_desc" mod="ptr" doc="The {AdapterDesc::} to fill.
Must not be NULL."/>
    </func>

    <!-- Device -->
    <func for="Device" name="Destroy" mod="custom-impl" doc="Destroys the {Device::} and all the extensions created by it.
Order of destruction is Extensions in which they were created, then device."/>

    <func for="Device" name="WaitForMultipleFences" doc="Waits on multiple fences simultaneously.
If wait_all is {MutiWaitFlags::All}, waits for all fences to be signaled.
Otherwise waits for any fence to be signaled.">
      <ret result="true"/>
      <arg type="FenceView" name="fences" mod="const ptr" doc="Array of fence views to wait on."/>
      <arg type="u64" name="fence_values" mod="const ptr" doc="Fence values to wait fences to reach.
Array must have fence_count values."/>
      <arg type="u32" name="fence_count" doc="How many fences to wait on."/>
      <arg type="MutiWaitFlags" name="wait_all" default="MutiWaitFlags::All" doc="Specifies the kind of wait. 
All - waits for all fences to be signaled.
Any - waits for any fence to be signaled.
Default is {MutiWaitFlags::All}"/>
      <arg type="u64" name="timeout" default="UINT64_MAX" doc="The timeout in nanoseconds. If UINT64_MAX, waits indefinitely."/>
    </func>

    <func for="Device" name="CreateFence" doc="Creates a fence with initial value and flags.">
      <ret type="Fence" name="fence" result="true" doc="{Fence::} on success ({Status::Ok})."/>
      <arg type="u64" name="initial_value" default="0" doc="The initial value of the fence."/>
      <arg type="FenceFlags" name="flags" default="FenceFlags::None" doc="The flags of the fence."/>
    </func>

    <func for="Device" name="CreateCommandQueue" doc="Creates a command queue with specified type.">
      <ret type="CommandQueue" name="queue" result="true" doc="{CommandQueue::} on success ({Status::Ok})."/>
      <arg type="QueueType" name="type" doc="The type of the queue to create."/>
    </func>

    <func for="Device" name="CreateCommandList" doc="Creates a command list for specific queue type.">
      <ret type="CommandList" name="list" result="true" doc="{CommandList::} on success ({Status::Ok})."/>
      <arg type="QueueType" name="type" doc="The type of the queue to create the command list for."/>
    </func>

    <func for="Device" name="CreateGraphicsPipeline" doc="Creates a graphics pipeline state object.">
      <ret type="PipelineState" name="pipeline" result="true" doc="{PipelineState::} on success ({Status::Ok})."/>
      <arg type="GraphicsPipelineDesc" name="desc" mod="const ptr" doc="The description of the graphics pipeline to create."/>
    </func>

    <func for="Device" name="CreateRootSignature" doc="Creates a root signature object.">
      <ret type="RootSignature" name="signature" result="true" doc="{RootSignature::} on success ({Status::Ok})."/>
      <arg type="RootConstant" name="root_constants" mod="const ptr" default="nullptr" doc="The root constants to create the root signature with."/>
      <arg type="u32" name="constants_size" default="0" doc="The number of root constants."/>
      <arg type="DescriptorTable" name="tables" mod="const ptr" default="nullptr" doc="The descriptor tables to create the root signature with."/>
      <arg type="u32" name="tables_count" default="0" doc="The number of descriptor tables."/>
    </func>

    <func for="Device" name="CreateShader" doc="Creates a shader object.">
      <ret type="Shader" name="shader" result="true" doc="{Shader::} on success ({Status::Ok})."/>
      <arg type="void" name="data" mod="ptr" doc="Shader bytecode."/>
      <arg type="u32" name="size" doc="The size of the shader data in bytes. For SPIR-V must be multiple of 4."/>
    </func>

    <func for="Device" name="CreateAllocator" doc="Creates a resource allocator object.">
      <ret type="ResourceAllocator" name="allocator" result="true" doc="{ResourceAllocator::} on success ({Status::Ok})."/>
    </func>

    <func for="Device" name="CreateRenderTarget" doc="Creates a render target object.">
      <ret type="RenderTarget" name="target" result="true" doc="{RenderTarget::} on success ({Status::Ok})."/>
      <arg type="TextureView" name="texture" doc="The texture view to create the render target with."/>
      <arg type="RenderTargetDesc" name="desc" doc="The description of the render target to create."/>
    </func>

    <func for="Device" name="CreateSampler" doc="Creates a sampler object.">
      <ret type="Sampler" name="sampler" result="true" doc="{Sampler::} on success ({Status::Ok})."/>
      <arg type="SamplerDesc" name="desc" mod="const ptr" doc="The description of the sampler to create."/>
    </func>

    <func for="Device" name="CreateShaderResource" doc="Creates a shader resource object.">
      <ret type="ShaderResource" name="resource" result="true" doc="{ShaderResource::} on success ({Status::Ok})."/>
      <arg type="TextureView" name="texture" doc="The texture view to create the shader resource with."/>
      <arg type="ShaderResourceDesc" name="desc" doc="The description of the shader resource to create."/>
    </func>

    <func for="Device" name="GetDescriptorTableAlignment" doc="Returns the alignment of the descriptor table in bytes.
The value is used to correctly determine descriptor page alignment for descriptor buffer.">
      <ret type="u32" name="alignment" result="true" doc="The alignment of the descriptor table in bytes."/>
      <arg type="DescriptorHeapType" name="heap" doc="The type of the descriptor heap to get the alignment for."/>
    </func>

    <func for="Device" name="GetDescriptorBufferUnitSize" doc="Returns the size of the descriptor buffer unit in bytes.">
      <ret type="u32" name="size" result="true" doc="The size of the descriptor buffer unit in bytes. Descriptor unit is the size of one descriptor."/>
      <arg type="DescriptorHeapType" name="heap" doc="The type of the descriptor heap to get the unit size for."/>
    </func>

    <func for="Device" name="CreateDescriptorBuffer" doc="Creates a descriptor buffer object.">
      <ret type="DescriptorBuffer" name="buffer" result="true" doc="{DescriptorBuffer::} on success ({Status::Ok})."/>
      <arg type="DescriptorHeapType" name="heap_type" doc="The type of the descriptor heap to create the descriptor buffer with."/>
      <arg type="DescriptorMemory" name="memory_type" doc="The type of the descriptor memory to create the descriptor buffer with."/>
      <arg type="u32" name="descriptor_count" doc="The number of descriptors to allocate in the descriptor buffer."/>
    </func>

    <func for="Device" name="QueryFeatureSupport" doc="Queries if the device supports the feature.">
      <ret type="bool" doc="true if feature is supported. false otherwise."/>
      <arg type="DeviceFeature" name="feature" doc="The feature to query."/>
    </func>


    <!--<func for="Fence" name="Destroy"/>
    <func for="ResourceAllocator" name="Destroy"/>
    <func for="RootSignature" name="Destroy"/>
    <func for="CommandQueue" name="Destroy"/>
    <func for="Shader" name="Destroy"/>
    <func for="PipelineState" name="Destroy"/>
    <func for="CommandList" name="Destroy"/>
    <func for="Buffer" name="Destroy"/>
    <func for="Texture" name="Destroy"/>
    <func for="SwapChain" name="Destroy"/>
    <func for="DebugMessenger" name="Destroy"/>
    <func for="RenderTarget" name="Destroy"/>
    <func for="DescriptorBuffer" name="Destroy"/>
    <func for="Sampler" name="Destroy"/>
    <func for="Memory" name="Destroy"/>
    <func for="ShaderResource" name="Destroy"/>-->

    <!-- Free Functions -->
    <func name="CreateFactory" mod="custom-impl" doc="Creates the {Factory::} with extensions, specified in extension array.">
      <ret type="Factory" name="factory" result="true" doc="{Factory::} on success ({Status::Ok})."/>
      <arg type="bool" name="debug_layer" default="false" doc="Enable the debug layer for underlying API."/>
      <arg type="FactoryExtension" name="extensions" mod="pp" default="nullptr" doc="The extensions to enable.
The extensions are initialized through this array.">
        <replace with="FactoryExtQuery" for="c" mod="ptr" default="nullptr" doc="Query the extensions that need to be present.
The extension pointers are initialized if the extension is found and initialized.
Otherwise returns NULL."/>
      </arg>
      <arg type="u32" name="extension_count" default="0" doc="The number of extensions to enable."/>
    </func>

    <func name="CreateDevice" mod="custom-impl" doc="Creates the {Device::} with extensions, specified in extension array.">
      <ret type="Device" name="device" result="true" doc="{Device::} on success ({Status::Ok})."/>
      <arg type="Adapter" name="adapter" doc="The adapter to create the logical device on. Must not be NULL."/>
      <arg type="DeviceExtension" name="extensions" mod="pp" default="nullptr" doc="The extensions to enable.
The extensions are initialized through this array.">
        <replace with="DeviceExtQuery" for="c" mod="ptr" default="nullptr" doc="Query the extensions that need to be present.
The extension pointers are initialized if the extension is found and initialized.
Otherwise returns NULL."/>
      </arg>
      <arg type="u32" name="extension_count" default="0" doc="The number of extensions to enable."/>
      <arg type="bool" name="force" default="false" doc="Create logical device even if some core functionality is absent.
The presence of core functionality is checked by the query function."/>
    </func>


  </functions>
  <extensions>
    <ext name="DebugExtension" type="Factory" id="1" folder="debug_info">
      <file include="wisdom/wisdom_debug.h"/>
      <func for="DebugExtension" name="CreateDebugMessenger" doc="Creates a debug messenger for the factory.">
        <ret type="DebugMessenger" name="messenger" result="true" doc="{DebugMessenger::} on success ({Status::Ok})."/>
        <arg type="DebugCallback" name="callback" doc="The callback that will receive the debug messages."/>
        <arg type="void" name="user_data" mod="ptr" doc="The user data that will be passed to the callback."/>"
      </func>
    </ext>
  </extensions>
</registry>
