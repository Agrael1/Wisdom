<?xml version="1.0" encoding="UTF-8"?>
<registry>
  <includes>
    <include>structs.xml</include>
  </includes>

  <handles>
    <handle name="Factory" doc="Class for creating adapters.
Can be safely destroyed after adapter has been chosen.">
      <file for="vk" include="vulkan/vk_factory.h"/>
      <file for="dx" include="dx12/dx12_factory.h"/>
    </handle>

    <handle name="Adapter" doc="Represents physical device.
Can safely be deleted once logical device has been created.">
      <file for="vk" include="vulkan/vk_adapter.h"/>
      <file for="dx" include="dx12/dx12_adapter.h"/>
    </handle>


    <handle name="Device" doc="Represents logical device.
Creates all the resources and commands for rendering.">
      <file for="vk" include="vulkan/vk_device.h"/>
      <file for="dx" include="dx12/dx12_device.h"/>
    </handle>

    <handle name="ResourceAllocator" doc="Main memory and resource allocator.
Uses DXMA and VMA libraries which can allocate memory with O(1) complexity with TLSF algorithm.">
      <file for="vk" include="vulkan/vk_allocator.h"/>
      <file for="dx" include="dx12/dx12_allocator.h"/>
    </handle>

    <handle name="CommandList" doc="Represents command list for recording commands.">
      <file for="vk" include="vulkan/vk_command_list.h"/>
      <file for="dx" include="dx12/dx12_command_list.h"/>
    </handle>

    <handle name="CommandQueue" doc="Represents command queue for executing command lists.">
      <file for="vk" include="vulkan/vk_command_queue.h"/>
      <file for="dx" include="dx12/dx12_command_queue.h"/>
    </handle>

    <handle name="DescriptorBuffer" doc="Represents descriptor buffer for binding descriptors.">
      <file for="vk" include="vulkan/vk_descriptor_buffer.h"/>
      <file for="dx" include="dx12/dx12_descriptor_buffer.h"/>
    </handle>

    <handle name="Fence" doc="Represents fence for synchronization of GPU timeline.">
      <file for="vk" include="vulkan/vk_fence.h"/>
      <file for="dx" include="dx12/dx12_fence.h"/>
    </handle>

    <handle name="Memory" doc="Represents memory object for binding resources.">
      <file for="vk" include="vulkan/vk_memory.h"/>
      <file for="dx" include="dx12/dx12_memory.h"/>
    </handle>

    <handle name="PipelineState" doc="Represents pipeline state object for rendering.">
      <file for="vk" include="vulkan/vk_pipeline_state.h"/>
      <file for="dx" include="dx12/dx12_pipeline_state.h"/>
    </handle>

    <handle name="Buffer" doc="Represents buffer object for storing linear data.">
      <file for="vk" include="vulkan/vk_resource.h"/>
      <file for="dx" include="dx12/dx12_resource.h"/>
    </handle>

    <handle name="Texture" doc="Represents texture object for storing image data.">
      <file for="vk" include="vulkan/vk_resource.h"/>
      <file for="dx" include="dx12/dx12_resource.h"/>
    </handle>

    <handle name="SwapChain" doc="Represents swap chain object for presenting images.">
      <file for="vk" include="vulkan/vk_swapchain.h"/>
      <file for="dx" include="dx12/dx12_swapchain.h"/>
    </handle>


    <handle name="RootSignature"/>
    <handle name="Shader"/>
    <handle name="DebugMessenger"/>
    <handle name="RenderTarget"/>
    <handle name="Sampler"/>
    <handle name="ShaderResource"/>
    <handle name="FactoryExtension"/>
    <handle name="DeviceExtension"/>
  </handles>

  <functions>
    <!-- Factory -->
    <func for="Factory" name="Destroy" mod="custom-impl" doc="Destroys the {Factory::} and all the extensions created by it.
Order of destruction is Extensions in which they were created, then factory."/>

    <func for="Factory" name="GetAdapter" mod="const" doc="Creates the {Adapter::} for the factory with provided index.">
      <ret type="Adapter" name="adapter" result="true" doc="{Adapter::} on success ({Status::Ok})."/>
      <arg type="u32" name="index" doc="The index of the adapter to get."/>
      <arg type="AdapterPreference" name="preference" default="Performance" doc="The preference of the adapter to get.
Default is {AdapterPreference::Performance}."/>
    </func>

    <!-- Adapter -->
    <func for="Adapter" name="Destroy" doc="Destroys the {Adapter::}."/>

    <func for="Adapter" name="GetDesc" mod="const" doc="Fills {AdapterDesc::} with physical adapter's data.">
      <ret result="true"/>
      <arg type="AdapterDesc" name="inout_desc" mod="ptr" doc="The {AdapterDesc::} to fill.
Must not be NULL."/>
    </func>

    <!-- Device -->
    <func for="Device" name="Destroy" mod="custom-impl" doc="Destroys the {Device::} and all the extensions created by it.
Order of destruction is Extensions in which they were created, then device."/>

    <func for="Device" name="WaitForMultipleFences" mod="const" doc="Waits on multiple fences simultaneously.
If wait_all is {MutiWaitFlags::All}, waits for all fences to be signaled.
Otherwise waits for any fence to be signaled.">
      <ret result="true"/>
      <arg type="FenceView" name="fences" mod="const ptr" doc="Array of fence views to wait on."/>
      <arg type="u64" name="fence_values" mod="const ptr" doc="Fence values to wait fences to reach.
Array must have fence_count values."/>
      <arg type="u32" name="fence_count" doc="How many fences to wait on."/>
      <arg type="MutiWaitFlags" name="wait_all" default="All" doc="Specifies the kind of wait.
All - waits for all fences to be signaled.
Any - waits for any fence to be signaled.
Default is {MutiWaitFlags::All}"/>
      <arg type="u64" name="timeout" default="UINT64_MAX" doc="The timeout in nanoseconds. If UINT64_MAX, waits indefinitely."/>
    </func>

    <func for="Device" name="CreateFence" mod="const" doc="Creates a fence with initial value and flags.">
      <ret type="Fence" name="fence" result="true" doc="{Fence::} on success ({Status::Ok})."/>
      <arg type="u64" name="initial_value" default="0" doc="The initial value of the fence."/>
      <arg type="FenceFlags" name="flags" default="None" doc="The flags of the fence."/>
    </func>

    <func for="Device" name="CreateCommandQueue" mod="const" doc="Creates a command queue with specified type.">
      <ret type="CommandQueue" name="queue" result="true" doc="{CommandQueue::} on success ({Status::Ok})."/>
      <arg type="QueueType" name="type" doc="The type of the queue to create."/>
    </func>

    <func for="Device" name="CreateCommandList" mod="const" doc="Creates a command list for specific queue type.">
      <ret type="CommandList" name="list" result="true" doc="{CommandList::} on success ({Status::Ok})."/>
      <arg type="QueueType" name="type" doc="The type of the queue to create the command list for."/>
    </func>

    <func for="Device" name="CreateGraphicsPipeline" mod="const" doc="Creates a graphics pipeline state object.">
      <ret type="PipelineState" name="pipeline" result="true" doc="{PipelineState::} on success ({Status::Ok})."/>
      <arg type="GraphicsPipelineDesc" name="desc" mod="const ptr" doc="The description of the graphics pipeline to create."/>
    </func>

    <func for="Device" name="CreateRootSignature" mod="const" doc="Creates a root signature object.">
      <ret type="RootSignature" name="signature" result="true" doc="{RootSignature::} on success ({Status::Ok})."/>
      <arg type="RootConstant" name="root_constants" mod="const ptr" default="nullptr" doc="The root constants to create the root signature with."/>
      <arg type="u32" name="constants_size" default="0" doc="The number of root constants."/>
      <arg type="DescriptorTable" name="tables" mod="const ptr" default="nullptr" doc="The descriptor tables to create the root signature with."/>
      <arg type="u32" name="tables_count" default="0" doc="The number of descriptor tables."/>
    </func>

    <func for="Device" name="CreateShader" mod="const" doc="Creates a shader object.">
      <ret type="Shader" name="shader" result="true" doc="{Shader::} on success ({Status::Ok})."/>
      <arg type="void" name="data" mod="ptr" doc="Shader bytecode."/>
      <arg type="u32" name="size" doc="The size of the shader data in bytes. For SPIR-V must be multiple of 4."/>
    </func>

    <func for="Device" name="CreateAllocator" mod="const" doc="Creates a resource allocator object.">
      <ret type="ResourceAllocator" name="allocator" result="true" doc="{ResourceAllocator::} on success ({Status::Ok})."/>
    </func>

    <func for="Device" name="CreateRenderTarget" mod="const" doc="Creates a render target object.">
      <ret type="RenderTarget" name="target" result="true" doc="{RenderTarget::} on success ({Status::Ok})."/>
      <arg type="Texture" name="texture" doc="The texture to create the render target with.">
        <replace with="TextureView" for="cpp" doc="The texture view to create the render target with."/>
      </arg>
      <arg type="RenderTargetDesc" name="desc" doc="The description of the render target to create."/>
    </func>

    <func for="Device" name="CreateDepthStencilTarget" mod="const" doc="Creates a depth stencil target object.
Works only with depth formats.
Used with render passes.">
      <ret type="RenderTarget" name="target" result="true" doc="{RenderTarget::} on success ({Status::Ok})."/>
      <arg type="Texture" name="texture" doc="The texture to create the render target with.">
        <replace with="TextureView" for="cpp" doc="The texture view to create the render target with."/>
      </arg>
      <arg type="RenderTargetDesc" name="desc" doc="The description of the render target to create.
Does not work with 3D textures."/>
    </func>

    <func for="Device" name="CreateSampler" mod="const" doc="Creates a sampler object.">
      <ret type="Sampler" name="sampler" result="true" doc="{Sampler::} on success ({Status::Ok})."/>
      <arg type="SamplerDesc" name="desc" mod="const ptr" doc="The description of the sampler to create."/>
    </func>

    <func for="Device" name="CreateShaderResource" mod="const" doc="Creates a shader resource object.">
      <ret type="ShaderResource" name="resource" result="true" doc="{ShaderResource::} on success ({Status::Ok})."/>
      <arg type="Texture" name="texture" doc="The texture to create the shader resource with.">
        <replace with="TextureView" for="cpp" doc="The texture view to create the shader resource with."/>
      </arg>
      <arg type="ShaderResourceDesc" name="desc" doc="The description of the shader resource to create."/>
    </func>

    <func for="Device" name="GetDescriptorTableAlignment" mod="const" doc="Returns the alignment of the descriptor table in bytes.
The value is used to correctly determine descriptor page alignment for descriptor buffer.">
      <ret type="u32" name="alignment" doc="The alignment of the descriptor table in bytes."/>
      <arg type="DescriptorHeapType" name="heap" doc="The type of the descriptor heap to get the alignment for."/>
    </func>

    <func for="Device" name="GetDescriptorBufferUnitSize" mod="const" doc="Returns the size of the descriptor buffer unit in bytes.">
      <ret type="u32" name="size" doc="The size of the descriptor buffer unit in bytes. Descriptor unit is the size of one descriptor."/>
      <arg type="DescriptorHeapType" name="heap" doc="The type of the descriptor heap to get the unit size for."/>
    </func>

    <func for="Device" name="CreateDescriptorBuffer" mod="const" doc="Creates a descriptor buffer object.">
      <ret type="DescriptorBuffer" name="buffer" result="true" doc="{DescriptorBuffer::} on success ({Status::Ok})."/>
      <arg type="DescriptorHeapType" name="heap_type" doc="The type of the descriptor heap to create the descriptor buffer with."/>
      <arg type="DescriptorMemory" name="memory_type" doc="The type of the descriptor memory to create the descriptor buffer with."/>
      <arg type="u64" name="size_bytes" doc="The number of bytes to allocate for the descriptor buffer."/>
    </func>

    <func for="Device" name="QueryFeatureSupport" mod="const" doc="Queries if the device supports the feature.">
      <ret type="bool" doc="true if feature is supported. false otherwise."/>
      <arg type="DeviceFeature" name="feature" doc="The feature to query."/>
    </func>

    <!-- Resource Allocator -->
    <func for="ResourceAllocator" name="Destroy" doc="Destroys the {ResourceAllocator::}.
You can still use memory allocated by it even if it is destroyed."/>

    <func for="ResourceAllocator" name="CreateBuffer" mod="const" doc="Creates a buffer object and allocates memory for it.
Equivalent to creating a Buffer, allocating a memory and binding buffer to it.">
      <ret type="Buffer" name="buffer" result="true" doc="{Buffer::} on success ({Status::Ok})."/>
      <arg type="u64" name="size" doc="The size of the buffer in bytes."/>
      <arg type="BufferUsage" name="usage" doc="The usage of the buffer. May affect the alignment of the buffer memory allocation."/>
      <arg type="MemoryType" name="memory" default="Default" doc="The type of the memory to allocate for the buffer."/>
      <arg type="MemoryFlags" name="mem_flags" default="None" doc="The flags of the memory to allocate for the buffer."/>
    </func>

    <func for="ResourceAllocator" name="CreateTexture" mod="const" doc="Creates a texture object and allocates memory for it.
Equivalent to creating a Texture, allocating a memory and binding texture to it.">
      <ret type="Texture" name="texture" result="true" doc="{Texture::} on success ({Status::Ok})."/>
      <arg type="TextureDesc" name="desc" mod="const ref" doc="The description of the texture to create."/>
      <arg type="MemoryType" name="memory" default="Default" doc="The type of the memory to allocate for the texture."/>
      <arg type="MemoryFlags" name="mem_flags" default="None" doc="The flags of the memory to allocate for the texture."/>
    </func>

    <func for="ResourceAllocator" name="GetTextureAllocationInfo" mod="const" doc="Returns the allocation info for the texture.">
      <ret type="AllocationInfo" name="info" doc="The allocation info for the texture. Contains size and alignment. Useful if allocating memory manually."/>
      <arg type="TextureDesc" name="desc" mod="const ref" doc="The description of the texture to get the allocation info for."/>
    </func>

    <func for="ResourceAllocator" name="GetBufferAllocationInfo" mod="const" doc="Returns the allocation info for the buffer.">
      <ret type="AllocationInfo" name="info" doc="The allocation info for the buffer. Contains size and alignment. Useful if allocating memory manually."/>
      <arg type="u64" name="size" doc="The size of the buffer to get the allocation info for."/>
      <arg type="BufferUsage" name="usage" doc="The usage of the buffer. May affect the alignment of the buffer memory allocation."/>
    </func>

    <func for="ResourceAllocator" name="AllocateTextureMemory" mod="const" doc="Allocates memory for the image.">
      <ret type="Memory" name="out_memory" result="true" doc="{Memory::} on success ({Status::Ok})."/>
      <arg type="u64" name="size" doc="The size of the memory to allocate."/>
      <arg type="TextureUsage" name="usage" doc="The usage of the image memory."/>
      <arg type="MemoryType" name="mem_type" default="Default" doc="The type of the memory to allocate for the image."/>
      <arg type="MemoryFlags" name="mem_flags" default="None" doc="The flags of the memory to allocate for the image."/>
    </func>

    <func for="ResourceAllocator" name="AllocateBufferMemory" mod="const" doc="Allocates memory for the buffer.">
      <ret type="Memory" name="out_memory" result="true" doc="{Memory::} on success ({Status::Ok})."/>
      <arg type="u64" name="size" doc="The size of the memory to allocate."/>
      <arg type="BufferUsage" name="usage" doc="The usage of the buffer memory."/>
      <arg type="MemoryType" name="mem_type" default="Default" doc="The type of the memory to allocate for the buffer."/>
      <arg type="MemoryFlags" name="mem_flags" default="None" doc="The flags of the memory to allocate for the buffer."/>
    </func>

    <func for="ResourceAllocator" name="PlaceBuffer" mod="const" doc="Creates buffer with provided memory.
Equivalent to creating aliasing resource.
Note, the resulting buffer must be destroyed before Memory backing it up.">
      <ret type="Buffer" name="buffer" result="true" doc="{Buffer::} on success ({Status::Ok})."/>
      <arg type="Memory" name="memory" doc="The memory to bind the buffer to.">
        <replace with="MemoryView" for="cpp" doc="The memory to bind the buffer to."/>
      </arg>
      <arg type="u64" name="memory_offset" doc="The offset in the memory to bind the buffer to."/>
      <arg type="u64" name="size" doc="The size of the buffer to bind."/>
      <arg type="BufferUsage" name="usage" doc="The usage of the buffer."/>
    </func>

    <func for="ResourceAllocator" name="PlaceTexture" mod="const" doc="Creates texture with provided memory.
Equivalent to creating aliasing resource.
Note, the resulting Texture must be destroyed before Memory backing it up.">
      <ret type="Texture" name="texture" result="true" doc="{Texture::} on success ({Status::Ok})."/>
      <arg type="Memory" name="memory" doc="The memory to bind the buffer to.">
        <replace with="MemoryView" for="cpp" doc="The memory to bind the buffer to."/>
      </arg>
      <arg type="u64" name="memory_offset" doc="The offset in the memory to bind the texture to."/>
      <arg type="TextureDesc" name="desc" mod="const ref" doc="The description of the texture to create."/>
    </func>

    <!-- DebugMessenger -->
    <func for="DebugMessenger" name="Destroy" doc="Destroys the {DebugMessenger::}."/>

    <!-- Command List -->
    <func for="CommandList" name="Destroy" doc="Destroys the {CommandList::}."/>
    <func for="CommandList" name="Closed" mod="const" doc="Closes the command list for recording.">
      <ret type="bool" name="closed" doc="true if command list is closed. false otherwise."/>
    </func>

    <func for="CommandList" name="Close" doc="Closes the command list for recording.">
      <ret type="bool" name="closed" doc="true if command list is closed. false otherwise."/>
    </func>

    <func for="CommandList" name="Reset" doc="Resets the command list for recording. Can't be reset while executed!">
      <ret result="true"/>
      <arg type="PipelineState" name="initial_state" default="{}" doc="The pipeline to use as a starting state. Default is empty pipeline.">
        <replace with="PipelineView" for="cpp" default="{}" doc="The pipeline to use as a starting state. Default is empty pipeline."/>
      </arg>
    </func>

    <func for="CommandList" name="SetPipelineState" doc="Switches command list to use new pipeline. All the operations will be recorded with regards to the new bound pipeline.">
      <arg type="PipelineState" name="pipeline" doc="The pipeline to use with the command list with.">
        <replace with="PipelineView" for="cpp" doc="The pipeline to use with the command list with."/>
      </arg>
    </func>

    <func for="CommandList" name="CopyBuffer" doc="Copies data from one buffer to another.">
      <arg type="Buffer" name="source" doc="The source buffer to copy from.">
        <replace with="BufferView" for="cpp" doc="The source buffer to copy from."/>
      </arg>
      <arg type="Buffer" name="destination" doc="The destination buffer to copy to.">
        <replace with="BufferView" for="cpp" doc="The destination buffer to copy to."/>
      </arg>
      <arg type="BufferRegion" name="region" doc="The region to copy."/>
    </func>

    <func for="CommandList" name="CopyBufferToTexture" doc="Copies data from buffer to texture.">
      <arg type="Buffer" name="source" doc="The source buffer to copy from.">
        <replace with="BufferView" for="cpp" doc="The source buffer to copy from."/>
      </arg>
      <arg type="Texture" name="destination" doc="The destination texture to copy to.">
        <replace with="TextureView" for="cpp" doc="The destination texture to copy to."/>
      </arg>
      <arg type="BufferTextureCopyRegion" name="regions" mod="const ptr" doc="The regions to copy."/>
      <arg type="u32" name="region_count" doc="The number of regions to copy."/>
    </func>

    <func for="CommandList" name="CopyTextureToBuffer" doc="Copies data from one texture to another.">
      <arg type="Texture" name="source" doc="The source texture to copy from.">
        <replace with="TextureView" for="cpp" doc="The source texture to copy from."/>
      </arg>
      <arg type="Buffer" name="destination" doc="The destination buffer to copy to.">
        <replace with="BufferView" for="cpp" doc="The destination buffer to copy to."/>
      </arg>
      <arg type="BufferTextureCopyRegion" name="regions" mod="const ptr" doc="The regions to copy."/>
      <arg type="u32" name="region_count" doc="The number of regions to copy."/>
    </func>

    <func for="CommandList" name="BufferBarrier" doc="Sets the barrier on the buffer.">
      <arg type="BufferBarrier" name="barrier" doc="The barrier to set."/>
      <arg type="Buffer" name="buffer" doc="The buffer to set the barrier on.">
        <replace with="BufferView" for="cpp" doc="The buffer to set the barrier on."/>
      </arg>
    </func>

    <func for="CommandList" name="BufferBarriers" doc="Sets the barriers on the buffers. You may set up to 8 buffer barriers for max efficiency.">
      <arg type="BufferBarrier2" name="barriers" mod="const ptr" doc="The barriers to set."/>
      <arg type="u32" name="barrier_count" doc="The number of barriers to set."/>
    </func>

    <func for="CommandList" name="TextureBarrier" doc="Sets the barrier on the texture.">
      <arg type="TextureBarrier" name="barrier" doc="The barrier to set."/>
      <arg type="Texture" name="texture" doc="The texture to set the barrier on.">
        <replace with="TextureView" for="cpp" doc="The texture to set the barrier on."/>
      </arg>
    </func>

    <func for="CommandList" name="TextureBarriers" doc="Sets the barriers on the textures. You may set up to 8 texture barriers for max efficiency.">
      <arg type="TextureBarrier2" name="barriers" mod="const ptr" doc="The barriers to set."/>
      <arg type="u32" name="barrier_count" doc="The number of barriers to set."/>
    </func>

    <func for="CommandList" name="BeginRenderPass" doc="Begins the render pass.">
      <arg type="RenderPassDesc" name="pass_desc" mod="const ptr" doc="The description of the render pass to begin."/>
    </func>

    <func for="CommandList" name="EndRenderPass" doc="Ends the render pass."/>

    <func for="CommandList" name="SetRootSignature" doc="Sets the pipeline signature object. Used to determine how to pick descriptors from descriptor buffer.">
      <arg type="RootSignature" name="root_signature" doc="The root signature to set.">
        <replace with="RootSignatureView" for="cpp" doc="The root signature to set."/>
      </arg>
    </func>

    <func for="CommandList" name="IASetPrimitiveTopology" doc="Sets the primitive topology. Detemines how vertices shall be processed.">
      <arg type="PrimitiveTopology" name="topology" doc="The primitive topology to set."/>
    </func>

    <func for="CommandList" name="IASetVertexBuffers" doc="Sets the vertex buffers.">
      <arg type="VertexBufferBinding" name="resources" mod="const ptr" doc="The vertex buffers to set."/>
      <arg type="u32" name="count" doc="The number of vertex buffers to set."/>
      <arg type="u32" name="start_slot" default="0" doc="The start slot to set the vertex buffers to. Default is 0."/>
    </func>

    <func for="CommandList" name="IASetIndexBuffer" doc="Sets the index buffer.">
      <arg type="Buffer" name="buffer" doc="The index buffer to set.">
        <replace with="BufferView" for="cpp" doc="The index buffer to set."/>
      </arg>
      <arg type="IndexType" name="type" doc="The type of the index buffer."/>
      <arg type="u64" name="offset" doc="The offset in the index buffer in bytes."/>
    </func>

    <func for="CommandList" name="IASetIndexBuffer2" doc="Sets the index buffer.
You may provide the offset in the buffer to take only a range of the buffer.
Requires {DeviceFeature::AdvancedIndexBuffer} to be supported.">
      <arg type="Buffer" name="buffer" doc="The index buffer to set.">
        <replace with="BufferView" for="cpp" doc="The index buffer to set."/>
      </arg>
      <arg type="IndexType" name="type" doc="The type of the index buffer."/>
      <arg type="u32" name="size" doc="The size of the index buffer in bytes."/>
      <arg type="u64" name="offset" doc="The offset in the index buffer in bytes."/>
    </func>

    <func for="CommandList" name="RSSetViewport" doc="Sets the viewport.">
      <arg type="Viewport" name="viewport" doc="The viewport to set."/>
    </func>

    <func for="CommandList" name="RSSetViewports" doc="Sets multiple viewports.">
      <arg type="Viewport" name="viewports" mod="const ptr" doc="The viewports to set."/>
      <arg type="u32" name="count" doc="The number of viewports to set."/>
    </func>

    <func for="CommandList" name="RSSetScissor" doc="Sets the scissor rect.">
      <arg type="Scissor" name="scissor" doc="The scissor to set."/>
    </func>

    <func for="CommandList" name="RSSetScissors" doc="Sets multiple scissor rects.
Each n-th rect corresponds to n-th Viewport set in RSSetViewports if SV_ViewportArrayIndex is used in geometry shader.
Otherwise the first is chosen.">
      <arg type="Scissor" name="scissors" mod="const ptr" doc="The scissors to set."/>
      <arg type="u32" name="count" doc="The number of scissors to set."/>
    </func>

    <func for="CommandList" name="DrawIndexedInstanced" doc="Draws indexed instanced geometry.">
      <arg type="u32" name="vertex_count_per_instance" doc="The number of vertices to draw per instance."/>
      <arg type="u32" name="instance_count" default="1" doc="The number of instances to draw. Default is 1."/>
      <arg type="u32" name="start_index" default="0" doc="The index of the first vertex to draw. Default is 0."/>
      <arg type="u32" name="base_vertex" default="0" doc="The index of the first vertex to start drawing from. Default is 0."/>
      <arg type="u32" name="start_instance" default="0" doc="The index of the first instance to draw. Default is 0."/>
    </func>

    <func for="CommandList" name="DrawInstanced" doc="Draws instanced geometry. (Without indexing)">
      <arg type="u32" name="vertex_count_per_instance" doc="The number of vertices to draw per instance."/>
      <arg type="u32" name="instance_count" default="1" doc="The number of instances to draw. Default is 1."/>
      <arg type="u32" name="start_vertex" default="0" doc="The index of the first vertex to draw. Default is 0."/>
      <arg type="u32" name="start_instance" default="0" doc="The index of the first instance to draw. Default is 0."/>
    </func>

    <func for="CommandList" name="SetRootConstants" doc="Sets the root constants for the shader.">
      <arg type="void" name="data" mod="ptr" doc="The data to set the root constants with."/>
      <arg type="u32" name="size_4bytes" doc="The size of the data in 4-byte units."/>
      <arg type="u32" name="offset_4bytes" doc="The offset in the data in 4-byte units."/>
      <arg type="ShaderStages" name="stage" doc="The shader stages to set the root constants for."/>
    </func>

    <func for="CommandList" name="SetDescriptorBuffers" doc="Sets the root descriptor tables for the shader.
Operation will perform flush in some cases, so it's not recommended to rebind descriptor buffers too often. ">
      <arg type="DescriptorBufferView" name="buffers" mod="const ptr" doc="The descriptor buffers to set the root descriptor tables with.
May only be one of each type (one Descriptor and one Sampler buffer)"/>
      <arg type="u32" name="buffer_count" doc="The number of descriptor buffers to set. May be 1 or 2."/>
    </func>

    <func for="CommandList" name="SetDescriptorTableOffset" doc="Sets the offset in the descriptor table for the descriptor buffer.">
      <arg type="u32" name="root_table_index" doc="The index of the root table to set the offset for."/>
      <arg type="DescriptorBuffer" name="buffer" doc="The descriptor buffer to set the offset for.">
        <replace with="DescriptorBufferGPUView" for="cpp" doc="The descriptor buffer to set the offset for."/>
      </arg>
      <arg type="u32" name="offset_bytes" doc="The offset in the descriptor buffer in bytes."/>
    </func>


    <!-- CommandQueue -->
    <func for="CommandQueue" name="Destroy" doc="Destroys the {CommandQueue::}."/>

    <func for="CommandQueue" name="ExecuteCommandLists" mod="const" doc="Executes the command lists.">
      <arg type="CommandListView" name="lists" mod="const ptr" doc="The command lists to execute."/>
      <arg type="u32" name="count" doc="The number of command lists to execute."/>
    </func>

    <func for="CommandQueue" name="SignalQueue" mod="const" doc="Enqueue the signal to the queue, that gets executed after all the work has been done.">
      <ret result="true"/>
      <arg type="Fence" name="fence" doc="The fence to signal.">
        <replace with="FenceView" for="cpp" doc="The fence to signal."/>
      </arg>
      <arg type="u64" name="value" doc="The value to signal the fence with."/>
    </func>

    <func for="CommandQueue" name="WaitQueue" mod="const" doc="Enqueues wait operation to the command queue. Queue then waits for the fence to be signalled from CPU or from another queue.
Can still be enqueued after the signal.">
      <ret result="true"/>
      <arg type="Fence" name="fence" doc="The fence to wait on.">
        <replace with="FenceView" for="cpp" doc="The fence to wait on."/>
      </arg>
      <arg type="u64" name="value" doc="The value to wait the fence to reach."/>
    </func>

    <!-- DescriptorBuffer -->
    <func for="DescriptorBuffer" name="Destroy" doc="Destroys the {DescriptorBuffer::}."/>

    <func for="DescriptorBuffer" name="WriteSampler" doc="Writes the sampler to the sampler descriptor buffer.
Must be called with Sampler descriptor buffer, which was created with {DescriptorHeapType::Sampler}.">
      <ret type="u64" name="byte_position_after" doc="Byte offset from buffer beginning. May help determine next table address."/>
      <arg type="u64" name="aligned_table_offset" doc="Byte offset from the buffer beginning in table alignment sizes.
Alignment may be queried with {Device::GetDescriptorTableAlignment}."/>
      <arg type="u32" name="index" doc="Binding index in descriptor table."/>
      <arg type="Sampler" name="sampler" doc="The sampler to write.">
        <replace with="SamplerView" for="cpp" doc="The sampler to write."/>
      </arg>
    </func>

    <func for="DescriptorBuffer" name="WriteShaderResource2" doc="Writes the shader resource to the shader resource descriptor buffer.
Must be called with Shader Resource descriptor buffer, which was created with {DescriptorHeapType::Descriptor}.
Requires {DeviceFeature::DescriptorEqualSize} to run, otherwise program is ill-formed.">
      <ret type="u64" name="byte_position_after" doc="Byte offset from buffer beginning. May help determine next table address."/>
      <arg type="u64" name="aligned_table_offset" doc="Byte offset from the buffer beginning in table alignment sizes.
Alignment may be queried with {Device::GetDescriptorTableAlignment}."/>
      <arg type="u32" name="index" doc="Binding index in descriptor table."/>
      <arg type="ShaderResource" name="resource" doc="The shader resource to write.">
        <replace with="ShaderResourceView" for="cpp" doc="The shader resource to write."/>
      </arg>
    </func>

    <func for="DescriptorBuffer" name="WriteConstantBuffer2" doc="Writes the constant buffer to the constant buffer descriptor buffer.
Must be called with Constant Buffer descriptor buffer, which was created with {DescriptorHeapType::Descriptor}.
Requires {DeviceFeature::DescriptorEqualSize} to run, otherwise program is ill-formed.">
      ">
      <ret type="u64" name="byte_position_after" doc="Byte offset from buffer beginning. May help determine next table address."/>
      <arg type="u64" name="aligned_table_offset" doc="Byte offset from the buffer beginning in table alignment sizes.
Alignment may be queried with {Device::GetDescriptorTableAlignment}."/>
      <arg type="u32" name="index" doc="Binding index in descriptor table."/>
      <arg type="Buffer" name="buffer" doc="The buffer to write.">
        <replace with="BufferView" for="cpp" doc="The buffer to write."/>
      </arg>
      <arg type="u32" name="buffer_size" doc="The size of the buffer in bytes."/>
    </func>

    <func for="DescriptorBuffer" name="WriteShaderResource" doc="Writes the shader resource to the shader resource descriptor buffer.">
      <ret type="u64" name="byte_position_after" doc="Byte offset from buffer beginning. May help determine next table address."/>
      <arg type="u64" name="aligned_table_offset" doc="Byte offset from the buffer beginning in table alignment sizes.
Alignment may be queried with {Device::GetDescriptorTableAlignment}."/>
      <arg type="u32" name="root_table_index" doc="Index of the descriptor table in {RootSignature::}"/>
      <arg type="u32" name="binding" doc="Binding index in descriptor table."/>
      <arg type="u32" name="array_member" doc="Array member index in the binding."/>
      <arg type="RootSignature" name="root_signature" doc="The root signature to get the binding position from.">
        <replace with="RootSignatureView2" for="cpp" doc="The root signature to get the binding position from."/>
      </arg>
      <arg type="ShaderResource" name="resource" doc="The shader resource to write.">
        <replace with="ShaderResourceView" for="cpp" doc="The shader resource to write."/>
      </arg>
    </func>

    <func for="DescriptorBuffer" name="WriteConstantBuffer" doc="Writes the constant buffer to the constant buffer descriptor buffer.">
      <ret type="u64" name="byte_position_after" doc="Byte offset from buffer beginning. May help determine next table address."/>
      <arg type="u64" name="aligned_table_offset" doc="Byte offset from the buffer beginning in table alignment sizes.
Alignment may be queried with {Device::GetDescriptorTableAlignment}."/>
      <arg type="u32" name="root_table_index" doc="Index of the descriptor table in {RootSignature::}"/>
      <arg type="u32" name="binding" doc="Binding index in descriptor table."/>
      <arg type="u32" name="array_member" doc="Array member index in the binding."/>
      <arg type="RootSignature" name="root_signature" doc="The root signature to get the binding position from.">
        <replace with="RootSignatureView2" for="cpp" doc="The root signature to get the binding position from."/>
      </arg>
      <arg type="Buffer" name="buffer" doc="The buffer to write.">
        <replace with="BufferView" for="cpp" doc="The buffer to write."/>
      </arg>
      <arg type="u32" name="buffer_size" doc="The size of the buffer in bytes."/>
    </func>


    <!-- Fence -->
    <func for="Fence" name="Destroy" doc="Destroys the {Fence::}."/>

    <func for="Fence" name="GetCompletedValue" mod="const" doc="Get the current value of the fence.">
      <ret type="u64" name="value" doc="Value of the fence."/>
    </func>

    <func for="Fence" name="Wait" mod="const" doc="Wait on CPU for the fence to reach a certain value.">
      <ret result="true"/>
      <arg type="u64" name="value" doc="Value to wait for."/>
      <arg type="u64" name="wait_ns" default="UINT64_MAX" doc="The time to wait for the fence to reach the value in nanoseconds. Default is infinite."/>
    </func>

    <func for="Fence" name="Signal" mod="const" doc="Signal the fence from CPU.">
      <ret result="true"/>
      <arg type="u64" name="value" doc="Value to signal."/>
    </func>

    <!-- Memory -->
    <func for="Memory" name="Destroy" doc="Destroys the {Memory::}."/>
    <func for="Memory" name="GetBlockOffset" mod="const" doc="Returns the offset of the block in the global memory.">
      <ret type="u64" name="offset" doc="The offset of the block in the global memory."/>
    </func>

    <!-- PipelineState -->
    <func for="PipelineState" name="Destroy" doc="Destroys the {PipelineState::}."/>

    <!-- Buffer -->
    <func for="Buffer" name="Destroy" doc="Destroys the {Buffer::}."/>
    <func for="Buffer" name="MapRaw" mod="const" doc="Maps the buffer memory to CPU address space.">
      <ret type="void" mod="ptr" name="data" doc="The pointer to the mapped memory."/>
    </func>
    <func for="Buffer" name="Unmap" mod="const" doc="Unmaps the buffer memory from CPU address space."/>

    <!-- Texture -->
    <func for="Texture" name="Destroy" doc="Destroys the {Texture::}."/>

    <!-- RenderTarget -->
    <func for="RenderTarget" name="Destroy" doc="Destroys the {RenderTarget::}."/>

    <!-- Sampler -->
    <func for="Sampler" name="Destroy" doc="Destroys the {Sampler::}."/>

    <!-- ShaderResource -->
    <func for="ShaderResource" name="Destroy" doc="Destroys the {ShaderResource::}."/>

    <!-- RootSignature -->
    <func for="RootSignature" name="Destroy" doc="Destroys the {RootSignature::}."/>

    <!-- Shader -->
    <func for="Shader" name="Destroy" doc="Destroys the {Shader::}."/>

    <!-- SwapChain -->
    <func for="SwapChain" name="Destroy" doc="Destroys the {SwapChain::}."/>
    <func for="SwapChain" name="GetCurrentIndex" mod="const" doc="Get the current image index in the swapchain.">
      <ret type="u32" name="index" doc="Index of the current image."/>
    </func>
    <func for="SwapChain" name="StereoSupported" mod="const" doc="Check if stereo is supported.">
      <ret type="bool" doc="true if stereo is supported."/>
    </func>
    <func for="SwapChain" name="Resize" doc="Resize the swapchain.
Transition may be expensive.
For the method to succeed, all swapchain buffers must be destroyed first">
      <ret result="true"/>
      <arg type="u32" name="width" doc="New width"/>
      <arg type="u32" name="height" doc="New height"/>
    </func>

    <func for="SwapChain" name="Present" doc="Present the swapchain.
Presentation always gets queued to the queue specified upon creation.">
      <ret result="true"/>
    </func>

    <func for="SwapChain" name="Present2" doc="Present the swapchain with vsync option.
Requires {DeviceFeature::DynamicVSync} to be supported.
Otherwise is identical to {SwapChain::Present}.">
      <ret result="true"/>
      <arg type="bool" name="in_vsync" doc="Enable vsync."/>
    </func>

    <func for="SwapChain" name="GetBuffers" mod="const custom-impl c-only" doc="Get the back buffers of the swapchain.">
      <ret type="u32" name="count" doc="Buffer count."/>
      <arg type="Texture" name="buffers" mod="const pp" doc="The back buffers of the swapchain.
If NULL, returns the amount of images swapchain has."/>
    </func>

    <func for="SwapChain" name="WaitForPresent" mod="const" doc="Wait for the presentation to finish.">
      <ret result="true"/>
      <arg type="u64" name="timeout_ns" default="UINT64_MAX" doc="The timeout in nanoseconds. Default is infinite."/>
    </func>

    <!-- Free Functions -->
    <func name="CreateFactory" mod="custom-impl" doc="Creates the {Factory::} with extensions, specified in extension array.">
      <ret type="Factory" name="factory" result="true" doc="{Factory::} on success ({Status::Ok})."/>
      <arg type="bool" name="debug_layer" default="false" doc="Enable the debug layer for underlying API."/>
      <arg type="FactoryExtension" name="extensions" mod="pp" default="nullptr" doc="The extensions to enable.
The extensions are initialized through this array.">
        <replace with="FactoryExtQuery" for="c" mod="ptr" default="nullptr" doc="Query the extensions that need to be present.
The extension pointers are initialized if the extension is found and initialized.
Otherwise returns NULL."/>
      </arg>
      <arg type="u32" name="extension_count" default="0" doc="The number of extensions to enable."/>
    </func>

    <func name="CreateDevice" mod="custom-impl" doc="Creates the {Device::} with extensions, specified in extension array.">
      <ret type="Device" name="device" result="true" doc="{Device::} on success ({Status::Ok})."/>
      <arg type="Adapter" name="adapter" doc="The adapter to create the logical device on. Must not be NULL."/>
      <arg type="DeviceExtension" name="extensions" mod="pp" default="nullptr" doc="The extensions to enable.
The extensions are initialized through this array.">
        <replace with="DeviceExtQuery" for="c" mod="ptr" default="nullptr" doc="Query the extensions that need to be present.
The extension pointers are initialized if the extension is found and initialized.
Otherwise returns NULL."/>
      </arg>
      <arg type="u32" name="extension_count" default="0" doc="The number of extensions to enable."/>
      <arg type="bool" name="force" default="false" doc="Create logical device even if some core functionality is absent.
The presence of core functionality is checked by the query function."/>
    </func>


  </functions>
  <extensions>
    <ext name="DebugExtension" type="Factory" id="1" folder="debug_info">
      <file include="wisdom/wisdom_debug.h"/>
      <func for="DebugExtension" name="CreateDebugMessenger" doc="Creates a debug messenger for the factory.">
        <ret type="DebugMessenger" name="messenger" result="true" doc="{DebugMessenger::} on success ({Status::Ok})."/>
        <arg type="DebugCallback" name="callback" doc="The callback that will receive the debug messages."/>
        <arg type="void" name="user_data" mod="ptr" doc="The user data that will be passed to the callback."/>"
      </func>
    </ext>
  </extensions>
</registry>
